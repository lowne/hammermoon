<html>
<title>hm.timer - Hammermoon documentation</title>
<meta charset="UTF-8">
<link href="docs.css" rel="stylesheet" type="text/css">
<link href="rainbow.css" rel="stylesheet" type="text/css">
<body>
<a name="//apple_ref/cpp/Module/hm.timer" class="dashAnchor"></a><h1 id="hm.timer">Module <code>hm.timer</code></h1><span class=short>Schedule asynchronous execution of functions in the future.</p><p class=long></p><h2>Overview</h2><dl><dt>Module <a href=hm.timer.html#hm.timer><code>hm.timer</code></a></dt><dd><a href=hm.timer.html#hm.timer-absoluteTime><code>absoluteTime()</code></a> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em> - function</dd><dd><a href=hm.timer.html#hm.timer-localTime><code>localTime()</code></a> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em> - function</dd><dd><a href=hm.timer.html#hm.timer-new><code>new(fn,data)</code></a> &ndash;&rsaquo; <a href=hm.timer.html#timer><em><code>&lt;#timer&gt;</code></em></a> - function</dd><dd><a href=hm.timer.html#hm.timer-sleep><code>sleep(s)</code></a> - function</dd><dd><a href=hm.timer.html#hm.timer-toSeconds><code>toSeconds(timeString)</code></a> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em> - function</dd></dl><dl><dt>Class <a href=hm.timer.html#timer><code>timer</code></a></dt><dd><a href=hm.timer.html#timer-elapsed><code>elapsed</code></a> : <em><code>&lt;#number&gt;</code></em> - property (read-only)</dd><dd><a href=hm.timer.html#timer-nextRun><code>nextRun</code></a> : <em><code>&lt;#number&gt;</code></em> - property</dd><dd><a href=hm.timer.html#timer-scheduled><code>scheduled</code></a> : <em><code>&lt;#boolean&gt;</code></em> - property</dd><dd><a href=hm.timer.html#timer-cancel><code>cancel()</code></a> - method</dd><dd><a href=hm.timer.html#timer-run><code>run()</code></a> - method</dd><dd><a href=hm.timer.html#timer-runAfter><code>runAfter(predicateFn,checkInterval,continueOnError,data)</code></a> - method</dd><dd><a href=hm.timer.html#timer-runEvery><code>runEvery(repeatInterval,delayOrStartTime,continueOnError,data)</code></a> - method</dd><dd><a href=hm.timer.html#timer-runIn><code>runIn(delay,data)</code></a> - method</dd><dd><a href=hm.timer.html#timer-runWhen><code>runWhen(predicateFn,checkInterval,continueOnError,data)</code></a> - method</dd><dd><a href=hm.timer.html#timer-runWhile><code>runWhile(predicateFn,checkInterval,continueOnError,data)</code></a> - method</dd><dd><a href=hm.timer.html#timer-setFn><code>setFn(fn)</code></a> &ndash;&rsaquo; <code>self</code> - method</dd></dl><dl><dt>Type <a href=hm.timer.html#intervalString><code>intervalString</code></a></dt></dl><dl><dt>Type <a href=hm.timer.html#timeOfDayString><code>timeOfDayString</code></a></dt></dl><dl><dt>Function prototypes</dt><dd><a href=hm.timer.html#predicateFunction><code>predicateFunction(data)</code></a> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em> - function prototype</dd><dd><a href=hm.timer.html#timerFunction><code>timerFunction(timer,data)</code></a> - function prototype</dd></dl><br><a name="//apple_ref/cpp/Module/hm.timer" class="dashAnchor"></a><h2 id="hm.timer">Module <code>hm.timer</code></h2><blockquote>Extends <a href=hm.html#module><em><code>&lt;hm#module&gt;</code></em></a></blockquote><span class=short></p><p class=long></p><a name="//apple_ref/cpp/Function/hm.timer.absoluteTime" class="dashAnchor"></a><h3 id="hm.timer-absoluteTime">Function <code>hm.timer.absoluteTime()</code> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em></h3><span class=short>Returns the number of seconds since an arbitrary point in the distant past.</p><ul><li>Returns <em><code>&lt;#number&gt;</code></em>: <span class=short>number of seconds, with millisecond precision or better</p></li></ul><p class=long>This function should only be used for measuring time intervals. The starting point is Jan 1 2001 00:00:00 GMT, so <em>not</em> the UNIX epoch.</p><a name="//apple_ref/cpp/Function/hm.timer.localTime" class="dashAnchor"></a><h3 id="hm.timer-localTime">Function <code>hm.timer.localTime()</code> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em></h3><span class=short>Returns the number of seconds since midnight local time.</p><ul><li>Returns <em><code>&lt;#number&gt;</code></em>: <span class=short>number of seconds, with millisecond precision or better</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Function/hm.timer.new" class="dashAnchor"></a><h3 id="hm.timer-new">Function <code>hm.timer.new(fn,data)</code> &ndash;&rsaquo; <a href=hm.timer.html#timer><em><code>&lt;#timer&gt;</code></em></a></h3><span class=short>Creates a new timer.</p><ul><li> <code>fn</code>: <a href=hm.timer.html#timerFunction><em><code>&lt;#timerFunction&gt;</code></em></a> <span class=short>(optional) a function to be executed later</p></li><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) arbitrary data that will be passed to <code>fn</code>; as a convenience, you can use the special string <code>"timer"</code>
       to have <code>fn</code> receive the timer object being created</p></li></ul><ul><li>Returns <a href=hm.timer.html#timer><em><code>&lt;#timer&gt;</code></em></a>: <span class=short>a new timer object</p></li></ul><p class=long>If <code>fn</code> is not provided here, it must be set via <a href="hm.timer.html#timer-setFn"><code>timer:setFn()</code></a> before calling any of the <code>:run...()</code> methods.
<code>data</code> can be overridden (and dynamically changed) later when calling the <code>:run...()</code> methods.</p><a name="//apple_ref/cpp/Function/hm.timer.sleep" class="dashAnchor"></a><h3 id="hm.timer-sleep">Function <code>hm.timer.sleep(s)</code></h3><span class=short>Halts all processing for a given interval.</p><ul><li> <code>s</code>: <em><code>&lt;#number&gt;</code></em> <span class=short>interval in seconds</p></li></ul><p class=long><strong>WARNING</strong>: this function will stop <em>all</em> processing by Hammermoon.
For anything other than very short intervals, use <a href="hm.timer.html#hm.timer-new"><code>hm.timer.new()</code></a> with a callback instead.</p><a name="//apple_ref/cpp/Function/hm.timer.toSeconds" class="dashAnchor"></a><h3 id="hm.timer-toSeconds">Function <code>hm.timer.toSeconds(timeString)</code> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em></h3><span class=short>Converts to number of seconds</p><ul><li> <code>timeString</code>: <em><code>&lt;#string&gt;</code></em> <span class=short>a <a href="hm.timer.html#timeOfDayString"><em><code><#timeOfDayString></code></em></a> or <a href="hm.timer.html#intervalString"><em><code><#intervalString></code></em></a></p></li></ul><ul><li>Returns <em><code>&lt;#number&gt;</code></em>: <span class=short>number of seconds in the interval (if <a href="hm.timer.html#intervalString"><em><code><#intervalString></code></em></a>) or after midnight (if <a href="hm.timer.html#timeOfDayString"><em><code><#timeOfDayString></code></em></a>)</p></li></ul><p class=long></p><br><a name="//apple_ref/cpp/Class/&lt;#timer&gt;" class="dashAnchor"></a><h2 id="timer">Class <code>timer</code></h2><blockquote>Extends <a href=hm.html#module.object><em><code>&lt;hm#module.object&gt;</code></em></a></blockquote><span class=short>Type for timer objects.</p><p class=long>A timer holds an execution unit that can be scheduled for running later in time in various ways via its <code>:run...()</code> methods.
 After being scheduled a timer can be unscheduled (thus prevented from running) via its [<code>:cancel()</code>](hm.timer.html#timer-cancel) method.</p><a name="//apple_ref/cpp/Property/&lt;#timer&gt;.elapsed" class="dashAnchor"></a><h3 id="timer-elapsed">Property (read-only) <code>&lt;#timer&gt;.elapsed</code>: <em><code>&lt;#number&gt;</code></em></h3><span class=short>The timer's last execution time, in seconds since.</p><p class=long>If the timer has never been executed, this value is the time since creation.</p><a name="//apple_ref/cpp/Property/&lt;#timer&gt;.nextRun" class="dashAnchor"></a><h3 id="timer-nextRun">Property <code>&lt;#timer&gt;.nextRun</code>: <em><code>&lt;#number&gt;</code></em></h3><span class=short>The timer's scheduled next execution time, in seconds from now.</p><p class=long>If this value is <code>nil</code>, the timer is currently unscheduled.
You cannot set this value to a negative number; setting it to <code>0</code> triggers timer execution right away;
setting it to <code>nil</code> unschedules the timer.</p><a name="//apple_ref/cpp/Property/&lt;#timer&gt;.scheduled" class="dashAnchor"></a><h3 id="timer-scheduled">Property <code>&lt;#timer&gt;.scheduled</code>: <em><code>&lt;#boolean&gt;</code></em></h3><span class=short><code>true</code> if the timer is scheduled for execution.</p><p class=long>Setting this to <code>false</code> or <code>nil</code> unschedules the timer.</p><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:cancel" class="dashAnchor"></a><h3 id="timer-cancel">Method <code>&lt;#timer&gt;:cancel()</code></h3><span class=short>Unschedule a timer.</p><p class=long>The timer's <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a> will not be executed again until you call one of its <code>:run...()</code> methods.</p><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:run" class="dashAnchor"></a><h3 id="timer-run">Method <code>&lt;#timer&gt;:run()</code></h3><span class=short>Executes the timer now.</p><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:runAfter" class="dashAnchor"></a><h3 id="timer-runAfter">Method <code>&lt;#timer&gt;:runAfter(predicateFn,checkInterval,continueOnError,data)</code></h3><span class=short>Schedules execution of the timer after a given predicate becomes false.</p><ul><li> <code>predicateFn</code>: <a href=hm.timer.html#predicateFunction><em><code>&lt;#predicateFunction&gt;</code></em></a> <span class=short>A predicate function that determines whether to contine waiting before executing the timer</p></li><li> <code>checkInterval</code>: <a href=hm.timer.html#intervalString><em><code>&lt;#intervalString&gt;</code></em></a> <span class=short>interval between predicate checks</p></li><li> <code>continueOnError</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, <code>predicateFn</code> will keep being checked even if it causes an error</p></li><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) arbitrary data that will be passed to the <a href="hm.timer.html#predicateFunction"><em><code><#predicateFunction></code></em></a> and <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a></p></li></ul><p class=long>The given <code>predicateFn</code> will start being checked right away. As soon as it returns <code>false</code>, the timer will
execute (once).</p><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:runEvery" class="dashAnchor"></a><h3 id="timer-runEvery">Method <code>&lt;#timer&gt;:runEvery(repeatInterval,delayOrStartTime,continueOnError,data)</code></h3><span class=short>Schedules repeated execution of the timer.</p><ul><li> <code>repeatInterval</code>: <a href=hm.timer.html#intervalString><em><code>&lt;#intervalString&gt;</code></em></a> <span class=short></p></li><li> <code>delayOrStartTime</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) the timer will start executing: if omitted or <code>nil</code>, right away; if an <a href="hm.timer.html#intervalString"><em><code><#intervalString></code></em></a> or a number (in seconds),
       after the given delay; if a <a href="hm.timer.html#timeOfDayString"><em><code><#timeOfDayString></code></em></a>, at the earliest occurrence for the given time</p></li><li> <code>continueOnError</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, the timer will keep repeating (and executing) even if its <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a> causes an error</p></li><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) arbitrary data that will be passed to the <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a></p></li></ul><p class=long>If <code>delayOrStartTime</code> is a <a href="hm.timer.html#timeOfDayString"><em><code><#timeOfDayString></code></em></a>, the timer will be scheduled to execute for the first time at the earliest occurrence
given the <code>repeatInterval</code>, e.g.:<li>If it's 17:00, <code>myTimer:runEvery("6h","0:00")</code> will set the timer 1 hour from now (at 18:00)</li><li>If it's 19:00, <code>myTimer:runEvery("6h","0:00")</code> will set the timer 5 hour from now (at 0:00 tomorrow)</li><li>If it's 21:00, <code>myTimer:runEvery("6h","20:00")</code> will set the timer 5 hours from now (at 2:00 tomorrow)</li></p><strong>Usage:</strong><br><pre><code class="language-lua">-- run a job every day at 8, regardless of when Hammermoon was (re)started:
hm.timer.new(doThisEveryMorning,myData):runEvery("1d","8:00")

-- run a job every hour on the hour from 8:00 to 20:00:
for h=8,20 do hm.timer.new(runJob):runEvery("1d",h..":00") end

-- start doing something every second in 5 seconds:
local myTimer=hm.timer.new(mustDoThisVeryOften)
myTimer:runEvery(1,5)
-- and later (maybe in some event callback), stop:
myTimer:cancel()</code></pre><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:runIn" class="dashAnchor"></a><h3 id="timer-runIn">Method <code>&lt;#timer&gt;:runIn(delay,data)</code></h3><span class=short>Schedules execution of the timer after a given delay.</p><ul><li> <code>delay</code>: <a href=hm.timer.html#intervalString><em><code>&lt;#intervalString&gt;</code></em></a> <span class=short></p></li><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) arbitrary data that will be passed to the <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a></p></li></ul><p class=long>Every time you call this method the "execution countdown" is restarted - i.e. any previous schedule (created
with any of the <code>:run...()</code> methods) is overwritten. This can be useful
to coalesce processing of unpredictable asynchronous events into a single
callback; for example, if you have an event stream that happens in "bursts" of dozens of events at once,
use an appropriate <code>delay</code> to wait for things to settle down, and then your callback will run just once.</p><strong>Usage:</strong><br><pre><code class="language-lua">local coalesceTimer=hm.timer.new(doSomethingExpensiveOnlyOnce)
local function burstyEventCallback(...)
  coalesceTimer:runIn(2.5) -- wait 2.5 seconds after the last event in the burst
end</code></pre><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:runWhen" class="dashAnchor"></a><h3 id="timer-runWhen">Method <code>&lt;#timer&gt;:runWhen(predicateFn,checkInterval,continueOnError,data)</code></h3><span class=short>Schedules execution of the timer every time a given predicate is true.</p><ul><li> <code>predicateFn</code>: <a href=hm.timer.html#predicateFunction><em><code>&lt;#predicateFunction&gt;</code></em></a> <span class=short>A predicate function that determines whether to execute the timer</p></li><li> <code>checkInterval</code>: <a href=hm.timer.html#intervalString><em><code>&lt;#intervalString&gt;</code></em></a> <span class=short>interval between predicate checks (and potential timer executions)</p></li><li> <code>continueOnError</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, <code>predicateFn</code> will keep being checked even if it - or the
       timer's <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a> - causes an error</p></li><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) arbitrary data that will be passed to the <a href="hm.timer.html#predicateFunction"><em><code><#predicateFunction></code></em></a> and <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a></p></li></ul><p class=long>The given <code>predicateFn</code> will start being checked right away. Every time it returns <code>true</code>, the timer will
execute.</p><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:runWhile" class="dashAnchor"></a><h3 id="timer-runWhile">Method <code>&lt;#timer&gt;:runWhile(predicateFn,checkInterval,continueOnError,data)</code></h3><span class=short>Schedules repeated execution of the timer while a given predicate remains true.</p><ul><li> <code>predicateFn</code>: <a href=hm.timer.html#predicateFunction><em><code>&lt;#predicateFunction&gt;</code></em></a> <span class=short>A predicate function that determines whether to contine executing the timer</p></li><li> <code>checkInterval</code>: <a href=hm.timer.html#intervalString><em><code>&lt;#intervalString&gt;</code></em></a> <span class=short>interval between predicate checks (and timer executions)</p></li><li> <code>continueOnError</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, the timer will keep repeating (and executing) even if
       its <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a> or <code>predicateFn</code> cause an error</p></li><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) arbitrary data that will be passed to the <a href="hm.timer.html#predicateFunction"><em><code><#predicateFunction></code></em></a> and <a href="hm.timer.html#timerFunction"><em><code><#timerFunction></code></em></a></p></li></ul><p class=long>The given <code>predicateFn</code> will start being checked right away. While it returns <code>true</code>, the timer will
execute; as soon as it returns <code>false</code> the timer will be canceled.</p><a name="//apple_ref/cpp/Method/&lt;#timer&gt;:setFn" class="dashAnchor"></a><h3 id="timer-setFn">Method <code>&lt;#timer&gt;:setFn(fn)</code> &ndash;&rsaquo; <code>self</code></h3><span class=short>Sets the function for this timer.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short></p></li></ul><ul><li>Returns <code>self</code>: <span class=short></p><a href=hm.timer.html#timer><em><code>&lt;#timer&gt;</code></em></a></li></ul><p class=long></p><br><a name="//apple_ref/cpp/Type/&lt;#intervalString&gt;" class="dashAnchor"></a><h3 id="intervalString">Type <code>intervalString</code></h3><blockquote>Extends <em><code>&lt;#string&gt;</code></em></blockquote><span class=short>A string describing a time interval.</p><p class=long>The following are valid formats: <code>"DDdHHh"</code>, <code>"HHhMMm"</code>, <code>"MMmSSs"</code>, <code>"DDd"</code>, <code>"HHh"</code>, <code>"MMm"</code>, <code>"SSs"</code>, <code>"NNNNms"</code> - they represent
an interval in days, hours, minutes, seconds and/or milliseconds.
You can also use a plain number (in seconds) wherever this type is expected.

Examples: <code>"1m30s"</code> or <code>90</code> (in seconds); <code>"1500ms"</code> or <code>1.5</code>.</p><br><a name="//apple_ref/cpp/Type/&lt;#timeOfDayString&gt;" class="dashAnchor"></a><h3 id="timeOfDayString">Type <code>timeOfDayString</code></h3><blockquote>Extends <em><code>&lt;#string&gt;</code></em></blockquote><span class=short>A string describing a time of day.</p><p class=long>The following are valid formats: <code>"HH:MM:SS"</code>, <code>"HH:MM"</code> or <code>"HHMM"</code> - they represent a time of day in hours, minutes, seconds (24-hour clock)
You can also use a plain number (in seconds after midnight) wherever this type is expected.

Examples: <code>"8:00:00"</code> or <code>"800"</code> or <code>28800</code> (in seconds).</p><br><br><a name="//apple_ref/cpp/Function/predicateFunction" class="dashAnchor"></a><h3 id="predicateFunction">Function prototype <code>predicateFunction(data)</code> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em></h3><span class=short>A predicate function that controls conditional execution of a timer.</p><ul><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the arbitrary data for this timer, or if <code>"timer"</code> was passed to <a href="hm.timer.html#hm.timer-new"><code>new()</code></a>, the timer itself</p></li></ul><ul><li>Returns <em><code>&lt;#boolean&gt;</code></em>: <span class=short>the return value will determine wheter to run, repeat, skip or cancel altogether the timer's execution, depending on what method was used</p></li></ul><p class=long></p><br><a name="//apple_ref/cpp/Function/timerFunction" class="dashAnchor"></a><h3 id="timerFunction">Function prototype <code>timerFunction(timer,data)</code></h3><span class=short>A function that will be executed by a timer.</p><ul><li> <code>timer</code>: <a href=hm.timer.html#timer><em><code>&lt;#timer&gt;</code></em></a> <span class=short>the timer that scheduled execution of this function</p></li><li> <code>data</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the arbitrary data for this timer, or if <code>"timer"</code> was passed to <a href="hm.timer.html#hm.timer-new"><code>new()</code></a>, the timer itself</p></li></ul><p class=long></p><br>
<script src="rainbow.js"></script>
</body>
</html>
