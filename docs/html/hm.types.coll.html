<html>
<title>hm.types.coll - Hammermoon documentation</title>
<meta charset="UTF-8">
<link href="docs.css" rel="stylesheet" type="text/css">
<link href="rainbow.css" rel="stylesheet" type="text/css">
<body>
<a name="//apple_ref/cpp/Module/hm.types.coll" class="dashAnchor"></a><h1 id="hm.types.coll">Module <code>hm.types.coll</code></h1><span class=short>Some utilities for collections in Lua tables.</p><p class=long>You can call the methods in this module as functions on "plain" tables, via the syntax
<code>new<em>table=coll.filter(coll.map(my</em>table, map<em>fn),filter</em>fn)</code>.
Alternatively, you can use the constructors and then call methods directly on the table, like this:
<code>new<em>table=coll.dict(my</em>table):map(map<em>fn):filter(filter</em>fn)</code>.
All tables or lists returned by coll methods, unless otherwise noted, will accept further coll methods.

The methods in this module can be used on these types of collections:
  - <em>lists</em>: ordered collections (also known as linear arrays) where the (non-unique) elements are stored as <em>values</em> for sequential integer keys starting from 1
  - <em>sets</em>: unordered sets where the (unique) elements are stored as <em>keys</em> whose value is the boolean <code>true</code> (or another constant)
  - <em>dicts</em>: associative tables (also known as maps) where both keys and their values are arbitrary; they can have a list part as well
  - <em>trees</em>, tables with multiple levels of nesting</p><h2>Overview</h2><dl><dt>Module <a href=hm.types.coll.html#hm.types.coll><code>hm.types.coll</code></a></dt><dd><a href=hm.types.coll.html#hm.types.coll-CtoNumberList><code>CtoNumberList(n,array)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - function</dd><dd><a href=hm.types.coll.html#hm.types.coll-dict><code>dict(table)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - function</dd><dd><a href=hm.types.coll.html#hm.types.coll-list><code>list(table)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - function</dd><dd><a href=hm.types.coll.html#hm.types.coll-set><code>set(table)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a> - function</dd></dl><dl><dt>Class <a href=hm.types.coll.html#coll.dict><code>coll.dict</code></a></dt><dd><a href=hm.types.coll.html#coll.dict-byKeys><code>byKeys(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-byValues><code>byValues(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-contains><code>contains(element,maxDepth)</code></a> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-copy><code>copy(maxDepth)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-every><code>every(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-everykv><code>everykv(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-filter><code>filter(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-filterkv><code>filterkv(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-find><code>find(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#?&gt;</code></em> or <em><code>nil</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-findkv><code>findkv(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#?&gt;</code></em> or <em><code>nil</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-foreach><code>foreach(fn)</code></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-foreachkv><code>foreachkv(fn)</code></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-key><code>key(element)</code></a> &ndash;&rsaquo; <em><code>&lt;?&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-keys><code>keys()</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em>,<a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-keysByValues><code>keysByValues(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-listKeys><code>listKeys()</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-listValues><code>listValues()</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-map><code>map(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-mapkv><code>mapkv(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-mapmerge><code>mapmerge(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-mapmergekv><code>mapmergekv(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-merge><code>merge(otherDict,inPlace)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-pairs><code>pairs()</code></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-reduce><code>reduce(fn,initialValue)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em></code>...</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-remove><code>remove(value)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-replace><code>replace(otherDict)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-toIndex><code>toIndex()</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.dict-values><code>values()</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.dict-valuesByKeys><code>valuesByKeys(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em> - method</dd></dl><dl><dt>Class <a href=hm.types.coll.html#coll.list><code>coll.list</code></a></dt><dd><a href=hm.types.coll.html#coll.list-append><code>append(value)</code></a> &ndash;&rsaquo; <code>self</code> - method</dd><dd><a href=hm.types.coll.html#coll.list-byValues><code>byValues(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-compact><code>compact(inPlace)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-concat><code>concat(otherList,inPlace)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-dedupe><code>dedupe(inPlace)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-icopy><code>icopy()</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-ievery><code>ievery(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-ifilter><code>ifilter(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-ifilterByField><code>ifilterByField(fieldName,value,unequal)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-ifind><code>ifind(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-ifindByField><code>ifindByField(fieldName,value,unequal)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-ifindLast><code>ifindLast(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-iforeach><code>iforeach(fn)</code></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-imap><code>imap(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-imapToField><code>imapToField(fieldName)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-imapcat><code>imapcat(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-imapkv><code>imapkv(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-index><code>index(element)</code></a> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-insert><code>insert(value,index)</code></a> &ndash;&rsaquo; <code>self</code> - method</dd><dd><a href=hm.types.coll.html#coll.list-ipairs><code>ipairs()</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em>,<a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-ireduce><code>ireduce(fn,initialValue)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em></code>...</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-iremove><code>iremove(element)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-keysByValues><code>keysByValues(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-lastIndex><code>lastIndex(element)</code></a> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-replace><code>replace(otherList)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-sort><code>sort(fn,inPlace)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-sortByField><code>sortByField(fieldName,inPlace,reverse)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-toDict><code>toDict(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-toDictByField><code>toDictByField(fieldName)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-toSet><code>toSet(value)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.list-tostring><code>tostring(separator)</code></a> &ndash;&rsaquo; <em><code>&lt;#string&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.list-unpack><code>unpack()</code></a> &ndash;&rsaquo; <em><code>&lt;?&gt;</code></em> - method</dd></dl><dl><dt>Class <a href=hm.types.coll.html#coll.set><code>coll.set</code></a></dt><dd><a href=hm.types.coll.html#coll.set-everyk><code>everyk(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.set-filterk><code>filterk(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.set-findk><code>findk(fn)</code></a> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em> or <em><code>nil</code></em> - method</dd><dd><a href=hm.types.coll.html#coll.set-foreachk><code>foreachk(fn)</code></a> - method</dd><dd><a href=hm.types.coll.html#coll.set-mapk><code>mapk(fn)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.set-merge><code>merge(otherSet,inPlace)</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a> - method</dd><dd><a href=hm.types.coll.html#coll.set-toList><code>toList()</code></a> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> - method</dd></dl><dl><dt>Type <a href=hm.types.coll.html#dict><code>dict</code></a></dt><dd><a href=hm.types.coll.html#dict-tostringShowsKeys><code>tostringShowsKeys()</code></a> &ndash;&rsaquo; <code>self</code> - method</dd><dd><a href=hm.types.coll.html#dict-tostringShowsValues><code>tostringShowsValues()</code></a> &ndash;&rsaquo; <code>self</code> - method</dd></dl><br><a name="//apple_ref/cpp/Module/hm.types.coll" class="dashAnchor"></a><h2 id="hm.types.coll">Module <code>hm.types.coll</code></h2><span class=short></p><p class=long></p><a name="//apple_ref/cpp/Function/hm.types.coll.CtoNumberList" class="dashAnchor"></a><h3 id="hm.types.coll-CtoNumberList">Function <code>hm.types.coll.CtoNumberList(n,array)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Creates a list object from a C array of numbers</p><ul><li> <code>n</code>: <em><code>&lt;#number&gt;</code></em> <span class=short>length of <code>array</code></p></li><li> <code>array</code>: <em><code>&lt;#cdata&gt;</code></em> <span class=short>C array</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>the new list</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Function/hm.types.coll.dict" class="dashAnchor"></a><h3 id="hm.types.coll-dict">Function <code>hm.types.coll.dict(table)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Creates a dict object.</p><ul><li> <code>table</code>: <em><code>&lt;#table&gt;</code></em> <span class=short>(optional) if omitted a new empty table will be created</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>the table, that will now accept the <a href="hm.types.coll.html#coll.dict"><em><code><#coll.dict></code></em></a> methods</p></li></ul><p class=long>You can also use the shortcut <code>coll(table)</code>.</p><a name="//apple_ref/cpp/Function/hm.types.coll.list" class="dashAnchor"></a><h3 id="hm.types.coll-list">Function <code>hm.types.coll.list(table)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Creates a list object.</p><ul><li> <code>table</code>: <em><code>&lt;#table&gt;</code></em> <span class=short>(optional) if omitted a new empty table will be created</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>the table, that will now accept the <a href="hm.types.coll.html#coll.list"><em><code><#coll.list></code></em></a> methods</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Function/hm.types.coll.set" class="dashAnchor"></a><h3 id="hm.types.coll-set">Function <code>hm.types.coll.set(table)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a></h3><span class=short>Creates a set object.</p><ul><li> <code>table</code>: <em><code>&lt;#table&gt;</code></em> <span class=short>(optional) if omitted a new empty table will be created</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a>: <span class=short>the table, that will now accept the <a href="hm.types.coll.html#coll.set"><em><code><#coll.set></code></em></a> methods</p></li></ul><p class=long></p><br><a name="//apple_ref/cpp/Class/&lt;#coll.dict&gt;" class="dashAnchor"></a><h2 id="coll.dict">Class <code>coll.dict</code></h2><span class=short>An associative table (also known as dictionary) where both keys and their values are arbitrary; it can have a list part as well</p><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:byKeys" class="dashAnchor"></a><h3 id="coll.dict-byKeys">Method <code>&lt;#coll.dict&gt;:byKeys(fn)</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em></h3><span class=short>Returns an iterator that returns <code>key,value</code> at every iteration, sorted by keys.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>(optional) a comparator function to determine the sorting order;
if omitted, uses <code><</code>; if <code>true</code>, uses <code>></code></p></li></ul><ul><li>Returns <em><code>&lt;#function&gt;</code></em>: <span class=short>an iterator function meant for "for" loops: <code>for k,v in my_coll:byKeys() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:byValues" class="dashAnchor"></a><h3 id="coll.dict-byValues">Method <code>&lt;#coll.dict&gt;:byValues(fn)</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em></h3><span class=short>Returns an iterator that returns <code>value,key</code> at every iteration, sorted by values.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>(optional) a comparator function to determine the sorting order;
if omitted, uses <code><</code>; if <code>true</code>, uses <code>></code></p></li></ul><ul><li>Returns <em><code>&lt;#function&gt;</code></em>: <span class=short>an iterator function meant for "for" loops: <code>for v,k in my_coll:byValues() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:contains" class="dashAnchor"></a><h3 id="coll.dict-contains">Method <code>&lt;#coll.dict&gt;:contains(element,maxDepth)</code> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em></h3><span class=short>Determines if a dict or tree contains a given object.</p><ul><li> <code>element</code>: <em><code>&lt;?&gt;</code></em> <span class=short>a value or object to search the collection for</p></li><li> <code>maxDepth</code>: <em><code>&lt;#number&gt;</code></em> <span class=short>(optional) on a tree, look for the element until this nesting level is reached; if omitted, defaults to 1</p></li></ul><ul><li>Returns <em><code>&lt;#number&gt;</code></em>: <span class=short>the nesting level where the element was found</p></li><li>Returns <em><code>nil</code></em>: <span class=short>if not found</p></li></ul><p class=long>This function does <em>not</em> handle cycles; use the <code>maxDepth</code> parameter with care.
When maxDepth>1, the tree is traversed depth-first.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:copy" class="dashAnchor"></a><h3 id="coll.dict-copy">Method <code>&lt;#coll.dict&gt;:copy(maxDepth)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Returns a copy of the collection.</p><ul><li> <code>maxDepth</code>: <em><code>&lt;#number&gt;</code></em> <span class=short>(optional) on a tree, create a copy of every node until this nesting level is reached; if omitted, defaults
to 1; if 0, returns the input table (no copy will be performed)</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a new collection containing the same data as this collection</p></li></ul><p class=long>This function does <em>not</em> handle cycles; use the <code>maxDepth</code> parameter with care.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:every" class="dashAnchor"></a><h3 id="coll.dict-every">Method <code>&lt;#coll.dict&gt;:every(fn)</code> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em></h3><span class=short>Checks if a predicate function is satisfied by every element of a dict.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a table value and its key, and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#boolean&gt;</code></em>: <span class=short><code>true</code> if <code>fn(value,key)</code> returns <code>true</code> for every element; <code>false</code> otherwise</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:everykv" class="dashAnchor"></a><h3 id="coll.dict-everykv">Method <code>&lt;#coll.dict&gt;:everykv(fn)</code> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em></h3><span class=short>Checks if a predicate function is satisfied by every element of a dict.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a table key and its value, and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#boolean&gt;</code></em>: <span class=short><code>true</code> if <code>fn(key,value)</code> returns <code>true</code> for every element; <code>false</code> otherwise</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:filter" class="dashAnchor"></a><h3 id="coll.dict-filter">Method <code>&lt;#coll.dict&gt;:filter(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Filters a dict by running a predicate function on its elements, in arbitrary order.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict value and its key, and returns a boolean
value: <code>true</code> if the element should be kept, <code>false</code> if it should be discarded</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a dict containing the elements for which <code>fn(value,key)</code> returns true</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:filterkv" class="dashAnchor"></a><h3 id="coll.dict-filterkv">Method <code>&lt;#coll.dict&gt;:filterkv(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Filters a dict by running a predicate function on its elements, in arbitrary order.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict key and its value, and returns a boolean
value: <code>true</code> if the element should be kept, <code>false</code> if it should be discarded</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a dict containing the elements for which <code>fn(value,key)</code> returns true</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:find" class="dashAnchor"></a><h3 id="coll.dict-find">Method <code>&lt;#coll.dict&gt;:find(fn)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#?&gt;</code></em> or <em><code>nil</code></em></h3><span class=short>Executes a predicate function across a dict, in arbitrary order, and returns the first element where that function returns true.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict value and its index, and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#?&gt;</code></em>: <span class=short>the first value of this dict that caused <code>fn(value,key)</code> to return <code>true</code>, and its key</p></li><li>Returns <em><code>nil</code></em>: <span class=short>if not found</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:findkv" class="dashAnchor"></a><h3 id="coll.dict-findkv">Method <code>&lt;#coll.dict&gt;:findkv(fn)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#?&gt;</code></em> or <em><code>nil</code></em></h3><span class=short>Executes a predicate function across a dict, in arbitrary order, and returns the first element where that function returns true.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict key and its value, and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#?&gt;</code></em>: <span class=short>the first key of this dict that caused <code>fn(key,value)</code> to return <code>true</code>, and its value</p></li><li>Returns <em><code>nil</code></em>: <span class=short>if not found</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:foreach" class="dashAnchor"></a><h3 id="coll.dict-foreach">Method <code>&lt;#coll.dict&gt;:foreach(fn)</code></h3><span class=short>Executes a function with side effects across a dict, in arbitrary order, discarding any results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict value and its key</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:foreachkv" class="dashAnchor"></a><h3 id="coll.dict-foreachkv">Method <code>&lt;#coll.dict&gt;:foreachkv(fn)</code></h3><span class=short>Executes a function with side effects across a dict, in arbitrary order, discarding any results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict key and its value</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:key" class="dashAnchor"></a><h3 id="coll.dict-key">Method <code>&lt;#coll.dict&gt;:key(element)</code> &ndash;&rsaquo; <em><code>&lt;?&gt;</code></em></h3><span class=short>Finds the key of a given element in a dict.</p><ul><li> <code>element</code>: <em><code>&lt;?&gt;</code></em> <span class=short>an object or value to search the table for</p></li></ul><ul><li>Returns <em><code>&lt;?&gt;</code></em>: <span class=short>the first key in the dict (in arbitrary order) whose associated value is <code>element</code>; <code>nil</code> if the element is not found</p></li></ul><p class=long>The table is traversed via <code>pairs</code> in arbitrary order; if <code>element</code> is associated to multiple keys
in the table, the first key found will be returned; subsequent calls to this method from the same
table <em>might</em> return a different key.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:keys" class="dashAnchor"></a><h3 id="coll.dict-keys">Method <code>&lt;#coll.dict&gt;:keys()</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em>,<a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Returns an iterator that returns <code>key,value</code> at every iteration, in arbitrary order.</p><ul><li>Returns <em><code>&lt;#function&gt;</code></em>,<a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>an iterator function and this collection, meant for "for" loops: <code>for k,v in my_coll:keys() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:keysByValues" class="dashAnchor"></a><h3 id="coll.dict-keysByValues">Method <code>&lt;#coll.dict&gt;:keysByValues(fn)</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em></h3><span class=short>Returns an iterator that returns <code>key,value</code> at every iteration, sorted by values.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>(optional) a comparator function to determine the sorting order;
if omitted, uses <code><</code>; if <code>true</code>, uses <code>></code></p></li></ul><ul><li>Returns <em><code>&lt;#function&gt;</code></em>: <span class=short>an iterator function meant for "for" loops: <code>for k,v in my_coll:keysByValues() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:listKeys" class="dashAnchor"></a><h3 id="coll.dict-listKeys">Method <code>&lt;#coll.dict&gt;:listKeys()</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Creates a list of the keys in this dict.</p><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short></p></li></ul><p class=long>This method returns a list containing the all the <em>keys</em> in this collection in arbitrary order.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:listValues" class="dashAnchor"></a><h3 id="coll.dict-listValues">Method <code>&lt;#coll.dict&gt;:listValues()</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Creates a list of the values in this dict.</p><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short></p></li></ul><p class=long>This method returns a list containing the all the <em>values</em> in this collection in arbitrary order.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:map" class="dashAnchor"></a><h3 id="coll.dict-map">Method <code>&lt;#coll.dict&gt;:map(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Executes a function across a dict (in arbitrary order) and collects the results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict value and its key, and returns
a new value for the element and, optionally, a new key. The key/value pair returned from
this function will be added to the result dict.</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a dict containing the results of calling the function on every element in this dict</p></li></ul><p class=long>Notes:<li>if <code>fn</code> doesn't return keys, the transformed values returned by it will be assigned to their respective original keys</li><li>if <code>fn</code> <em>does</em> return keys, and they are not unique, the previous element with the same key will be overwritten;</li>
  keep in mind that the iteration order, and therefore which value will ultimately be associated to a
  conflicted key, is arbitrary<li>if <code>fn</code> returns <code>nil</code>, the respective key in the result dict will be absent</li></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:mapkv" class="dashAnchor"></a><h3 id="coll.dict-mapkv">Method <code>&lt;#coll.dict&gt;:mapkv(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Executes a function across a dict (in arbitrary order) and collects the results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict key and its value, and returns
a new key and a new value. The key/value pair returned from this function will be added to the result dict.</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a dict containing the results of calling the function on every element in this dict</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:mapmerge" class="dashAnchor"></a><h3 id="coll.dict-mapmerge">Method <code>&lt;#coll.dict&gt;:mapmerge(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Executes, in arbitrary order across a dict, a function that returns dicts, and merges all of those dicts together.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict value and its key, and returns a dict</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a dict containing the merged results of calling <code>fn(value,key)</code> for every element in this dict</p></li></ul><p class=long>Exercise caution if the tables returned by <code>fn</code> can contain the same keys: see the caveat in <a href="hm.types.coll.html#coll.dict-merge"><code>coll.dict.merge</code></a>.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:mapmergekv" class="dashAnchor"></a><h3 id="coll.dict-mapmergekv">Method <code>&lt;#coll.dict&gt;:mapmergekv(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Executes, in arbitrary order across a dict, a function that returns dicts, and merges all of those dicts together.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a dict key and its value, and returns a dict</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a dict containing the merged results of calling <code>fn(key,value)</code> for every element in this dict</p></li></ul><p class=long>Exercise caution if the tables returned by <code>fn</code> can contain the same keys: see the caveat in <a href="hm.types.coll.html#coll.dict-merge"><code>coll.dict.merge</code></a>.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:merge" class="dashAnchor"></a><h3 id="coll.dict-merge">Method <code>&lt;#coll.dict&gt;:merge(otherDict,inPlace)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Merges elements from two dicts into one.</p><ul><li> <code>otherDict</code>: <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> <span class=short>a dict</p></li><li> <code>inPlace</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, this dict will be modified in-place, merging all the elements from <code>otherDict</code>,
and returned; otherwise a new dict will be created and returned</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>a dict containing both the key/value pairs in this dict and those in <code>otherDict</code></p></li></ul><p class=long>If <code>otherDict</code> has keys that are also present in this dict, the corresponding key/value pairs from this dict
will be <em>overwritten</em> in the result dict; <em>this is also true for the list parts of the tables</em>, if present.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:pairs" class="dashAnchor"></a><h3 id="coll.dict-pairs">Method <code>&lt;#coll.dict&gt;:pairs()</code></h3><span class=short>Alias for <code>:keys()</code></p><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:reduce" class="dashAnchor"></a><h3 id="coll.dict-reduce">Method <code>&lt;#coll.dict&gt;:reduce(fn,initialValue)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em></code>...</code></em></h3><span class=short>Reduces a dict to a value (or tuple), using a function.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that takes three or more parameters:<li>the result(s) emitted from the previous iteration, or <code>initialValue</code>(s) for the first iteration</li><li>an element value from this dict, in arbitrary order</li><li>the element key</li></p></li><li> <code>initialValue</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) the value(s) to pass to <code>fn</code> for the first iteration; if omitted, <code>fn</code> will
be passed <code>value1,value2,key2</code> (then <code>result,value3,key3</code> on the second iteration, and so on)</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>,<em></code>...</code></em>: <span class=short>the result(s) emitted by <code>fn</code> after the last iteration</p></li></ul><p class=long><code>fn</code> can simply return one of the two values passed (e.g. a custom "max" function) or calculate a wholly new
value from them (e.g. a custom "sum" function).</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:remove" class="dashAnchor"></a><h3 id="coll.dict-remove">Method <code>&lt;#coll.dict&gt;:remove(value)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Removes all occurrences of a given value from this dict.</p><ul><li> <code>value</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the value to remove</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>this dict with the given element removed</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:replace" class="dashAnchor"></a><h3 id="coll.dict-replace">Method <code>&lt;#coll.dict&gt;:replace(otherDict)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Replace all the key value pairs in this dict with key value pairs from another dict</p><ul><li> <code>otherDict</code>: <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a> <span class=short></p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>this dict</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:toIndex" class="dashAnchor"></a><h3 id="coll.dict-toIndex">Method <code>&lt;#coll.dict&gt;:toIndex()</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Creates a dict with keys and values swapped.</p><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>the resulting dict</p></li></ul><p class=long>Returns a dict where keys and values of this dict are swapped (i.e. an index table).
Any duplicates among the values in this dict will be discarded, as the keys in a Lua table are unique.</p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:values" class="dashAnchor"></a><h3 id="coll.dict-values">Method <code>&lt;#coll.dict&gt;:values()</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em></h3><span class=short>Returns an iterator that returns <code>value,key</code> at every iteration, in arbitrary order.</p><ul><li>Returns <em><code>&lt;#function&gt;</code></em>: <span class=short>an iterator function meant for "for" loops: <code>for v,k in my_coll:values() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.dict&gt;:valuesByKeys" class="dashAnchor"></a><h3 id="coll.dict-valuesByKeys">Method <code>&lt;#coll.dict&gt;:valuesByKeys(fn)</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em></h3><span class=short>Returns an iterator that returns <code>value,key</code> at every iteration, sorted by keys.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>(optional) a comparator function to determine the sorting order;
if omitted, uses <code><</code>; if <code>true</code>, uses <code>></code></p></li></ul><ul><li>Returns <em><code>&lt;#function&gt;</code></em>: <span class=short>an iterator function meant for "for" loops: <code>for v,k in my_coll:valuesByKeys() do...</code></p></li></ul><p class=long></p><br><a name="//apple_ref/cpp/Class/&lt;#coll.list&gt;" class="dashAnchor"></a><h2 id="coll.list">Class <code>coll.list</code></h2><blockquote>Extends <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></blockquote><span class=short>An ordered collection (also known as linear array) where the (non-unique) elements are stored as <em>values</em> for sequential integer keys starting from 1.</p><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:append" class="dashAnchor"></a><h3 id="coll.list-append">Method <code>&lt;#coll.list&gt;:append(value)</code> &ndash;&rsaquo; <code>self</code></h3><span class=short>Appends an element at the end of this list.</p><ul><li> <code>value</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the new element</p></li></ul><ul><li>Returns <code>self</code>: <span class=short></p><a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:byValues" class="dashAnchor"></a><h3 id="coll.list-byValues">Method <code>&lt;#coll.list&gt;:byValues(fn)</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em></h3><span class=short>Returns an iterator that returns <code>value,index</code> at every iteration, sorted by values.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>(optional) a comparator function to determine the sorting order;
if omitted, uses <code><</code>; if <code>true</code>, uses <code>></code></p></li></ul><ul><li>Returns <em><code>&lt;#function&gt;</code></em>: <span class=short>an iterator function meant for "for" loops: <code>for v,i in my_coll:byValues() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:compact" class="dashAnchor"></a><h3 id="coll.list-compact">Method <code>&lt;#coll.list&gt;:compact(inPlace)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Removes holes in a list table.</p><ul><li> <code>inPlace</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short></p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>the list with all the holes removed</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:concat" class="dashAnchor"></a><h3 id="coll.list-concat">Method <code>&lt;#coll.list&gt;:concat(otherList,inPlace)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Concatenates two lists into one.</p><ul><li> <code>otherList</code>: <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> <span class=short>a list</p></li><li> <code>inPlace</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, this list will be modified in-place, appending all the elements from <code>otherList</code>,
and returned; otherwise a new list will be created and returned</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list with all the elements from this list followed by all the elements from <code>otherList</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:dedupe" class="dashAnchor"></a><h3 id="coll.list-dedupe">Method <code>&lt;#coll.list&gt;:dedupe(inPlace)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Removes duplicates from a list</p><ul><li> <code>inPlace</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code> modifies and returns this list</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list without duplicate elements</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:icopy" class="dashAnchor"></a><h3 id="coll.list-icopy">Method <code>&lt;#coll.list&gt;:icopy()</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Returns a copy of this list.</p><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a new list containing the same elements as this collection</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ievery" class="dashAnchor"></a><h3 id="coll.list-ievery">Method <code>&lt;#coll.list&gt;:ievery(fn)</code> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em></h3><span class=short>Checks if a predicate function is satisfied by every element of a list.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a list value and its index, and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#boolean&gt;</code></em>: <span class=short><code>true</code> if <code>fn(value,index)</code> returns <code>true</code> for every element; <code>false</code> otherwise</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ifilter" class="dashAnchor"></a><h3 id="coll.list-ifilter">Method <code>&lt;#coll.list&gt;:ifilter(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Filters a list by running a predicate function on its elements in order.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a list element and its index, and returns a boolean
value: <code>true</code> if the element should be kept, <code>false</code> if it should be discarded</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list containing the elements for which <code>fn(element,index)</code> returns true</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ifilterByField" class="dashAnchor"></a><h3 id="coll.list-ifilterByField">Method <code>&lt;#coll.list&gt;:ifilterByField(fieldName,value,unequal)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Filters a list by an elements' field.</p><ul><li> <code>fieldName</code>: <em><code>&lt;#string&gt;</code></em> <span class=short>the elements' field to use for filtering</p></li><li> <code>value</code>: <em><code>&lt;?&gt;</code></em> <span class=short>if the element's <code>fieldName</code> doesn't have this value the element will be discarded</p></li><li> <code>unequal</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, <code>fieldName</code> must be <em>not</em> equal to <code>value</code> to allow the element</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>the resulting filtered list</p></li></ul><p class=long>Returns a new list containing only the elements whose <code>fieldName</code> equals (or if <code>unequal</code>
is not equal to) <code>value</code></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ifind" class="dashAnchor"></a><h3 id="coll.list-ifind">Method <code>&lt;#coll.list&gt;:ifind(fn)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em></h3><span class=short>Executes a predicate function across a list, in order, and returns the first element where that function returns true.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a list element and its index, and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em>: <span class=short>the first element of this list that caused <code>fn(value,index)</code> to return <code>true</code>, and its index</p></li><li>Returns <em><code>nil</code></em>: <span class=short>if not found</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ifindByField" class="dashAnchor"></a><h3 id="coll.list-ifindByField">Method <code>&lt;#coll.list&gt;:ifindByField(fieldName,value,unequal)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em></h3><span class=short>Returns the first element in this list whose field is equal to a given value.</p><ul><li> <code>fieldName</code>: <em><code>&lt;#string&gt;</code></em> <span class=short>the elements' field to use for filtering</p></li><li> <code>value</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the desired value</p></li><li> <code>unequal</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, <code>fieldName</code> must be <em>not</em> equal to <code>value</code> to be a match</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em>: <span class=short>the first element of this list that caused <code>fn(value,index)</code> to return <code>true</code>, and its index</p></li><li>Returns <em><code>nil</code></em>: <span class=short>if not found</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ifindLast" class="dashAnchor"></a><h3 id="coll.list-ifindLast">Method <code>&lt;#coll.list&gt;:ifindLast(fn)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em> or <em><code>nil</code></em></h3><span class=short>Executes a predicate function across a list, in reverse order, and returns the first element where that function returns true.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a list element and its index, and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>,<em><code>&lt;#number&gt;</code></em>: <span class=short>the highest-index element of this list that caused <code>fn(value,index)</code> to return <code>true</code>, and its index</p></li><li>Returns <em><code>nil</code></em>: <span class=short>if not found</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:iforeach" class="dashAnchor"></a><h3 id="coll.list-iforeach">Method <code>&lt;#coll.list&gt;:iforeach(fn)</code></h3><span class=short>Executes a function with side effects across a list in order, discarding any results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a list element and its index</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:imap" class="dashAnchor"></a><h3 id="coll.list-imap">Method <code>&lt;#coll.list&gt;:imap(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Executes a function across a list in order, and collects the results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts a list element and returns a value.
The values returned from this function will be collected, in order, into the result list; when <code>nil</code> is
returned the relevant element is discarded - the result list will <em>not</em> have "holes".</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list containing the results of calling the function on every element in this list</p></li></ul><p class=long>If this table has "holes", all elements after the first hole will be lost, as the table is iterated over with <code>ipairs</code>;
you can use <code>hs.func:dict()</code> if necessary.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:imapToField" class="dashAnchor"></a><h3 id="coll.list-imapToField">Method <code>&lt;#coll.list&gt;:imapToField(fieldName)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Creates a list by collecting a field from each element in this list.</p><ul><li> <code>fieldName</code>: <em><code>&lt;#string&gt;</code></em> <span class=short>the name of the field to collect</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list containing <code>fieldName</code> for each of the elements in this list</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:imapcat" class="dashAnchor"></a><h3 id="coll.list-imapcat">Method <code>&lt;#coll.list&gt;:imapcat(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Executes, in order across a list, a function that returns lists, and concatenates all of those lists together.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a list element and its index, and returns a list</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list containing the concatenated results of calling <code>fn(element,index)</code> for every element in this list</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:imapkv" class="dashAnchor"></a><h3 id="coll.list-imapkv">Method <code>&lt;#coll.list&gt;:imapkv(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Executes a function across a list in order, and collects the results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts two parameters, a list index and its element, and returns a value.
The values returned from this function will be collected, in order, into the result list; when <code>nil</code> is
returned the relevant element is discarded - the result list will <em>not</em> have "holes".</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list containing the results of calling the function on every element in this list</p></li></ul><p class=long>If this table has "holes", all elements after the first hole will be lost, as the table is iterated over with <code>ipairs</code>;
you can use <code>hs.func:dict()</code> if necessary.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:index" class="dashAnchor"></a><h3 id="coll.list-index">Method <code>&lt;#coll.list&gt;:index(element)</code> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em></h3><span class=short>Finds the index of a given element in a list.</p><ul><li> <code>element</code>: <em><code>&lt;?&gt;</code></em> <span class=short>an object or value to search the list for</p></li></ul><ul><li>Returns <em><code>&lt;#number&gt;</code></em>: <span class=short>a positive integer, the index of the first occurence of <code>element</code> in the list; <code>nil</code> if the element is not found</p></li></ul><p class=long>The table is traversed via <code>ipairs</code> in order; if <code>element</code> is associated to multiple indices
in the list, this funciton will always return the lowest one.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:insert" class="dashAnchor"></a><h3 id="coll.list-insert">Method <code>&lt;#coll.list&gt;:insert(value,index)</code> &ndash;&rsaquo; <code>self</code></h3><span class=short>Inserts an element to this list.</p><ul><li> <code>value</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the new element</p></li><li> <code>index</code>: <em><code>&lt;#number&gt;</code></em> <span class=short>(optional) the index for the new element; if omitted, <code>value</code> is appended at the end of this list</p></li></ul><ul><li>Returns <code>self</code>: <span class=short></p><a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ipairs" class="dashAnchor"></a><h3 id="coll.list-ipairs">Method <code>&lt;#coll.list&gt;:ipairs()</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em>,<a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Returns a list iterator that returns <code>key,value</code> at every iteration, in order.</p><ul><li>Returns <em><code>&lt;#function&gt;</code></em>,<a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>an iterator function and this list, meant for "for" loops: <code>for i,v in my_coll:ipairs() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:ireduce" class="dashAnchor"></a><h3 id="coll.list-ireduce">Method <code>&lt;#coll.list&gt;:ireduce(fn,initialValue)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em>,<em></code>...</code></em></h3><span class=short>Reduces a list to a value (or tuple), using a function.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>A function that takes three or more parameters:<li>the result(s) emitted from the previous iteration, or <code>initialValue</code>(s) for the first iteration</li><li>an element from this list, iterating in order</li><li>the element index</li></p></li><li> <code>initialValue</code>: <em><code>&lt;?&gt;</code></em> <span class=short>(optional) the value(s) to pass to <code>fn</code> for the first iteration; if omitted, <code>fn</code> will
be passed <code>elem1,elem2,2</code> (then <code>result,elem3,3</code> on the second iteration, and so on)</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>,<em></code>...</code></em>: <span class=short>the result emitted by <code>fn</code> after the last iteration</p></li></ul><p class=long><code>fn</code> can simply return one of the two elements passed (e.g. a "max" function) or calculate a wholly new
value from them (e.g. a "sum" function).</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:iremove" class="dashAnchor"></a><h3 id="coll.list-iremove">Method <code>&lt;#coll.list&gt;:iremove(element)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Removes all occurrences of a given element from this list.</p><ul><li> <code>element</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the element to remove</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>this list with the given element removed</p></li></ul><p class=long>This method will not create holes in the list.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:keysByValues" class="dashAnchor"></a><h3 id="coll.list-keysByValues">Method <code>&lt;#coll.list&gt;:keysByValues(fn)</code> &ndash;&rsaquo; <em><code>&lt;#function&gt;</code></em></h3><span class=short>Returns an iterator that returns <code>index,value</code> at every iteration, sorted by values.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>(optional) a comparator function to determine the sorting order;
if omitted, uses <code><</code>; if <code>true</code>, uses <code>></code></p></li></ul><ul><li>Returns <em><code>&lt;#function&gt;</code></em>: <span class=short>an iterator function meant for "for" loops: <code>for i,v in my_coll:keysByValues() do...</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:lastIndex" class="dashAnchor"></a><h3 id="coll.list-lastIndex">Method <code>&lt;#coll.list&gt;:lastIndex(element)</code> &ndash;&rsaquo; <em><code>&lt;#number&gt;</code></em></h3><span class=short>Finds the index of a given element in a list.</p><ul><li> <code>element</code>: <em><code>&lt;?&gt;</code></em> <span class=short>an object or value to search the list for</p></li></ul><ul><li>Returns <em><code>&lt;#number&gt;</code></em>: <span class=short>a positive integer, the index of the last occurence of <code>element</code> in the list; <code>nil</code> if the element is not found</p></li></ul><p class=long>The table is traversed in <em>reverse</em> order; if <code>element</code> is associated to multiple indices
in the list, this funciton will always return the highest one.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:replace" class="dashAnchor"></a><h3 id="coll.list-replace">Method <code>&lt;#coll.list&gt;:replace(otherList)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Replace all the elements in this list with elements from another list</p><ul><li> <code>otherList</code>: <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a> <span class=short></p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>this list, with all elements replaced</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:sort" class="dashAnchor"></a><h3 id="coll.list-sort">Method <code>&lt;#coll.list&gt;:sort(fn,inPlace)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Returns a sorted copy of this list.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>(optional) a function that accepts two list elements, and returns <code>true</code> if the first should come
-    before the second in the sorted return list; if <code>nil</code>, the <code><</code> (less than) operator is used</p></li><li> <code>inPlace</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code> modifies and returns this list</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list with the same elements of this list, sorted according to <code>fn</code></p></li></ul><p class=long>Unlike <code>table.sort</code>, this method can return a new list (in other words, the original list can be left untouched).</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:sortByField" class="dashAnchor"></a><h3 id="coll.list-sortByField">Method <code>&lt;#coll.list&gt;:sortByField(fieldName,inPlace,reverse)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Returns a sorted copy of this list.</p><ul><li> <code>fieldName</code>: <em><code>&lt;#string&gt;</code></em> <span class=short>The elements' field to use as sorting key; the <code><</code> (less than) operator is used as comparator</p></li><li> <code>inPlace</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code> modifies and returns this list</p></li><li> <code>reverse</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, the <code>></code> operator is used instead</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>a list with the same elements of this list, sorted by <code>fieldName</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:toDict" class="dashAnchor"></a><h3 id="coll.list-toDict">Method <code>&lt;#coll.list&gt;:toDict(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Creates a dict from a list.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts a list element and returns a key for it</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>the resulting dict</p></li></ul><p class=long>Returns a dict where the values are this list's values, and each key is determined
by a given function on each element.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:toDictByField" class="dashAnchor"></a><h3 id="coll.list-toDictByField">Method <code>&lt;#coll.list&gt;:toDictByField(fieldName)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></h3><span class=short>Creates a dict from a list, using a field of each element for its key.</p><ul><li> <code>fieldName</code>: <em><code>&lt;#string&gt;</code></em> <span class=short>the name of the field to use as each element's key</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a>: <span class=short>the resulting dict</p></li></ul><p class=long>Returns a dict where the values are this list's values, and each key is a given field
of each element.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:toSet" class="dashAnchor"></a><h3 id="coll.list-toSet">Method <code>&lt;#coll.list&gt;:toSet(value)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a></h3><span class=short>Creates a set from a list.</p><ul><li> <code>value</code>: <em><code>&lt;?&gt;</code></em> <span class=short>the constant value to assign to every key in the result table; if omitted, defaults to <code>true</code></p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a>: <span class=short>the resulting set</p></li></ul><p class=long>Returns a set whose keys are all the (unique) elements from this list.
Any duplicates among the elements in this list will be discarded, as the keys in a Lua table are unique.</p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:tostring" class="dashAnchor"></a><h3 id="coll.list-tostring">Method <code>&lt;#coll.list&gt;:tostring(separator)</code> &ndash;&rsaquo; <em><code>&lt;#string&gt;</code></em></h3><span class=short>Returns a string representation of this list.</p><ul><li> <code>separator</code>: <em><code>&lt;#string&gt;</code></em> <span class=short>(optional) if omitted defaults to <code>","</code></p></li></ul><ul><li>Returns <em><code>&lt;#string&gt;</code></em>: <span class=short></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.list&gt;:unpack" class="dashAnchor"></a><h3 id="coll.list-unpack">Method <code>&lt;#coll.list&gt;:unpack()</code> &ndash;&rsaquo; <em><code>&lt;?&gt;</code></em></h3><span class=short>Unpacks the elements in this list.</p><ul><li>Returns <em><code>&lt;?&gt;</code></em>: <span class=short>?,... all the elements in this list</p></li></ul><p class=long></p><br><a name="//apple_ref/cpp/Class/&lt;#coll.set&gt;" class="dashAnchor"></a><h2 id="coll.set">Class <code>coll.set</code></h2><blockquote>Extends <a href=hm.types.coll.html#coll.dict><em><code>&lt;#coll.dict&gt;</code></em></a></blockquote><span class=short>An unordered set where the (unique) elements are stored as <em>keys</em> whose value is the boolean <code>true</code> (or another constant)</p><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.set&gt;:everyk" class="dashAnchor"></a><h3 id="coll.set-everyk">Method <code>&lt;#coll.set&gt;:everyk(fn)</code> &ndash;&rsaquo; <em><code>&lt;#boolean&gt;</code></em></h3><span class=short>Checks if a predicate function is satisfied by every key of a set</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts a set key and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#boolean&gt;</code></em>: <span class=short><code>true</code> if <code>fn(key)</code> returns <code>true</code> for every element; <code>false</code> otherwise</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.set&gt;:filterk" class="dashAnchor"></a><h3 id="coll.set-filterk">Method <code>&lt;#coll.set&gt;:filterk(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a></h3><span class=short>Filters a set by running a predicate function on its elements, in arbitrary order.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts a key and returns a boolean
value: <code>true</code> if the key should be kept, <code>false</code> if it should be discarded</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a>: <span class=short>a set containing the keys for which <code>fn(key)</code> returns true</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.set&gt;:findk" class="dashAnchor"></a><h3 id="coll.set-findk">Method <code>&lt;#coll.set&gt;:findk(fn)</code> &ndash;&rsaquo; <em><code>&lt;#?&gt;</code></em> or <em><code>nil</code></em></h3><span class=short>Executes a predicate function across a set and returns the first key where that function returns true.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts a set key and returns a boolean</p></li></ul><ul><li>Returns <em><code>&lt;#?&gt;</code></em>: <span class=short>the first key of this set that caused <code>fn(key)</code> to return <code>true</code></p></li><li>Returns <em><code>nil</code></em>: <span class=short>if not found</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.set&gt;:foreachk" class="dashAnchor"></a><h3 id="coll.set-foreachk">Method <code>&lt;#coll.set&gt;:foreachk(fn)</code></h3><span class=short>Executes a function with side effects across a set, in arbitrary order, discarding any results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that accepts a set key</p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.set&gt;:mapk" class="dashAnchor"></a><h3 id="coll.set-mapk">Method <code>&lt;#coll.set&gt;:mapk(fn)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a></h3><span class=short>Executes a function across a set (in arbitrary order) and collects the results.</p><ul><li> <code>fn</code>: <em><code>&lt;#function&gt;</code></em> <span class=short>a function that a key and returns a new key, that will be added to the result set</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a>: <span class=short>a set containing the results of calling the function on every key in this set</p></li></ul><p class=long>Notes:<li>the keys returned by <code>fn</code> may be not unique, but a set doesn't allow duplicates</li></p><a name="//apple_ref/cpp/Method/&lt;#coll.set&gt;:merge" class="dashAnchor"></a><h3 id="coll.set-merge">Method <code>&lt;#coll.set&gt;:merge(otherSet,inPlace)</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a></h3><span class=short>Merges elements from two sets into one.</p><ul><li> <code>otherSet</code>: <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a> <span class=short>a dict</p></li><li> <code>inPlace</code>: <em><code>&lt;#boolean&gt;</code></em> <span class=short>(optional) if <code>true</code>, this set will be modified in-place</p></li></ul><ul><li>Returns <a href=hm.types.coll.html#coll.set><em><code>&lt;#coll.set&gt;</code></em></a>: <span class=short>a set containing both the keys in this set and those in <code>otherSet</code></p></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#coll.set&gt;:toList" class="dashAnchor"></a><h3 id="coll.set-toList">Method <code>&lt;#coll.set&gt;:toList()</code> &ndash;&rsaquo; <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a></h3><span class=short>Creates a list from a set.</p><ul><li>Returns <a href=hm.types.coll.html#coll.list><em><code>&lt;#coll.list&gt;</code></em></a>: <span class=short>the resulting list</p></li></ul><p class=long>Returns a list containing the all the <em>keys</em> in this set in arbitrary order.</p><br><a name="//apple_ref/cpp/Type/&lt;#dict&gt;" class="dashAnchor"></a><h3 id="dict">Type <code>dict</code></h3><span class=short></p><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#dict&gt;:tostringShowsKeys" class="dashAnchor"></a><h3 id="dict-tostringShowsKeys">Method <code>&lt;#dict&gt;:tostringShowsKeys()</code> &ndash;&rsaquo; <code>self</code></h3><span class=short>Sets <code>tostring</code> of this dict to only print keys.</p><ul><li>Returns <code>self</code>: <span class=short></p><a href=hm.types.coll.html#dict><em><code>&lt;#dict&gt;</code></em></a></li></ul><p class=long></p><a name="//apple_ref/cpp/Method/&lt;#dict&gt;:tostringShowsValues" class="dashAnchor"></a><h3 id="dict-tostringShowsValues">Method <code>&lt;#dict&gt;:tostringShowsValues()</code> &ndash;&rsaquo; <code>self</code></h3><span class=short>Sets <code>tostring</code> of this dict to only print values.</p><ul><li>Returns <code>self</code>: <span class=short></p><a href=hm.types.coll.html#dict><em><code>&lt;#dict&gt;</code></em></a></li></ul><p class=long></p><br>
<script src="rainbow.js"></script>
</body>
</html>
